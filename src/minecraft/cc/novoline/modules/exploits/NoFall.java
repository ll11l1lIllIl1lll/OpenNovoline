package cc.novoline.modules.exploits;

import cc.novoline.events.EventTarget;
import cc.novoline.events.events.MotionUpdateEvent;
import cc.novoline.events.events.PacketEvent;
import cc.novoline.events.events.TickUpdateEvent;
import cc.novoline.gui.screen.setting.Manager;
import cc.novoline.gui.screen.setting.Setting;
import cc.novoline.gui.screen.setting.SettingType;
import cc.novoline.modules.AbstractModule;
import cc.novoline.modules.ModuleManager;
import cc.novoline.modules.configurations.annotation.Property;
import cc.novoline.modules.configurations.property.object.BooleanProperty;
import cc.novoline.modules.configurations.property.object.PropertyFactory;
import cc.novoline.utils.ServerUtils;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition;
import org.checkerframework.checker.nullness.qual.NonNull;

import static cc.novoline.modules.EnumModuleType.EXPLOITS;

public final class NoFall extends AbstractModule {

    @Property("no-void")
    private BooleanProperty no_void = PropertyFactory.createBoolean(false);

    /* constructors @on */
    public NoFall(@NonNull ModuleManager novoline) {
        super(novoline, "NoFall", "No Fall", EXPLOITS, "Prevents you from taking fall damage");
        Manager.put(new Setting("NF_NO_VOID", "Void Check", SettingType.CHECKBOX, this, no_void));
    }

    private double getLastTickYDistance() {
        return Math.hypot(mc.player.posY - mc.player.prevPosY, mc.player.posY - mc.player.prevPosY);
    }

    @EventTarget
    public void onPacket(PacketEvent event) {
        if (event.getState().equals(PacketEvent.State.OUTGOING)) {
            if (ServerUtils.isHypixel()) {
                if (mc.player.posY > 0 && mc.player.fallDistance >= 2 && mc.player.lastTickPosY - mc.player.posY > 0 && mc.player.motionY != 0) {
                    if (no_void.get() && !mc.player.isBlockUnder() || mc.player.fallDistance > 255 || !mc.player.isBlockUnder() && mc.player.fallDistance > 50) {
                        return;
                    }

                    if (event.getPacket() instanceof C02PacketUseEntity) {
                        C02PacketUseEntity packet = (C02PacketUseEntity) event.getPacket();

                        if (packet.getAction() == C02PacketUseEntity.Action.ATTACK) {
                            event.setCancelled(true);
                        }
                    }

                    if (event.getPacket() instanceof C03PacketPlayer) {
                        C03PacketPlayer packet = (C03PacketPlayer) event.getPacket();

                        if (packet.isMoving() && packet.isRotating()) {
                            sendPacketNoEvent(new C04PacketPlayerPosition(packet.getX(), packet.getY(), packet.getZ(), packet.isOnGround()));
                            event.setCancelled(true);
                        }
                    }
                }
            }
        }
    }

    @EventTarget
    public void onMotion(MotionUpdateEvent event) {
        if (event.getState().equals(MotionUpdateEvent.State.PRE)) {
            if (mc.player.posY > 0 && mc.player.lastTickPosY - mc.player.posY > 0 && mc.player.motionY != 0 && mc.player.fallDistance >= 2.5) {
                if (no_void.get() && !mc.player.isBlockUnder() || mc.player.fallDistance > 255 || !mc.player.isBlockUnder() && mc.player.fallDistance > 50) {
                    return;
                }

                if (mc.player.fallDistance > 10 || mc.player.ticksExisted % 2 == 0) {
                    sendPacketNoEvent(new C03PacketPlayer(true));
                    mc.timer.timerSpeed = 1.0F;
                }
            }
        }
    }

    @EventTarget
    public void onTick(TickUpdateEvent event) {
        setSuffix("Watchdog");
    }

    @Override
    public void onEnable() {
        setSuffix("Watchdog");
    }
}
