package ninja.leaping.configurate.util;

import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;
import net.Qq;

class MapFactories$SynchronizedWrapper implements ConcurrentMap {
   private final Map wrapped;

   private MapFactories$SynchronizedWrapper(Map var1) {
      this.wrapped = var1;
   }

   public Object putIfAbsent(Object param1, Object param2) {
      // $FF: Couldn't be decompiled
   }

   public boolean remove(Object param1, Object param2) {
      // $FF: Couldn't be decompiled
   }

   public boolean replace(Object param1, Object param2, Object param3) {
      // $FF: Couldn't be decompiled
   }

   public Object replace(Object param1, Object param2) {
      // $FF: Couldn't be decompiled
   }

   public int size() {
      // $FF: Couldn't be decompiled
   }

   public boolean isEmpty() {
      // $FF: Couldn't be decompiled
   }

   public boolean containsKey(Object param1) {
      // $FF: Couldn't be decompiled
   }

   public boolean containsValue(Object param1) {
      // $FF: Couldn't be decompiled
   }

   public Object get(Object param1) {
      // $FF: Couldn't be decompiled
   }

   public Object put(Object param1, Object param2) {
      // $FF: Couldn't be decompiled
   }

   public Object remove(Object param1) {
      // $FF: Couldn't be decompiled
   }

   public void putAll(Map param1) {
      // $FF: Couldn't be decompiled
   }

   public void clear() {
      // $FF: Couldn't be decompiled
   }

   public Set keySet() {
      // $FF: Couldn't be decompiled
   }

   public Collection values() {
      // $FF: Couldn't be decompiled
   }

   public Set entrySet() {
      // $FF: Couldn't be decompiled
   }

   public boolean equals(Object param1) {
      // $FF: Couldn't be decompiled
   }

   public int hashCode() {
      // $FF: Couldn't be decompiled
   }

   public String toString() {
      // $FF: Couldn't be decompiled
   }

   MapFactories$SynchronizedWrapper(Map var1, Qq var2) {
      this(var1);
   }
}
